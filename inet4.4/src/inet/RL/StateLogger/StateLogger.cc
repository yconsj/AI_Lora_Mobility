//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
// 

#include "inet/RL/StateLogger/StateLogger.h"
#include "inet/RL/modelfiles/policy_net_model.h"

#include <omnetpp.h>
#include <iostream>


namespace inet {

Define_Module(StateLogger);

StateLogger::StateLogger() {
    // TODO Auto-generated constructor stub
}

void StateLogger::initialize() {
    inputStateArray.clear(); // Clear any previous data (if needed)
    choiceArray.clear();
    rewardArray.clear();
    transmissionTimes.clear(); // Clear previous transmission times
    runnumber = getSimulation()->getActiveEnvir()->getConfigEx()->getActiveRunNumber();

}

void StateLogger::addTransmissionTime() {
    transmissionTimes.push_back(simTime().dbl());
}

void StateLogger::logStationaryGatewayPacketReception(int gwIndex) {
    // Log the reception time when a packet is received by a stationary gateway
    simtime_t currentTime = simTime();  // Get the current simulation time

    if (gwIndex == 0) {
        // Log for StationaryLoraGw[0]
        stationaryReceptionTimes.push_back(currentTime.dbl());
    } else if (gwIndex == 1) {
        // Log for StationaryLoraGw[1]
        stationaryReceptionTimes.push_back(currentTime.dbl());
    }
}

void StateLogger::logStep(InputStateBasic& inputState, int choice, double reward) {
    inputStateArray.push_back(inputState);
    choiceArray.push_back(choice);
    rewardArray.push_back(reward);
}


void StateLogger::writeToFile() {
    runnumber = getSimulation()->getActiveEnvir()->getConfigEx()->getActiveRunNumber();

    if (runnumber < 0) {
        throw cRuntimeError("Failed to fetch runnumber");
    }

    // Construct the filename based on the current runnumber
    std::string filename = std::string(log_file_basename) + "_" + std::to_string(runnumber) + ".json";
    std::ofstream outFile(filename);

    if (outFile.is_open()) {
        // Create a JSON object
        json outputJson;

        // Format for the state
        std::vector<std::string> stateFormat = {
            "gwPosition.x", "gwPosition.y", "stampPos1.x", "stampPos1.y",
            "stampPos2.x", "stampPos2.y", "timestamp1", "timestamp2",
            "numReceivedPackets", "timeOfSample"
        };

        // Add the structure to the JSON object
        outputJson["gw_data"]["stateformat"] = stateFormat;

        // Populate states, actions, and rewards in the JSON structure
        std::vector<std::vector<double>> states;
        for (const auto& state : inputStateArray) {
            states.push_back({
                state.gwPosition.x, state.gwPosition.y, state.stampPos1.x, state.stampPos1.y,
                state.stampPos2.x, state.stampPos2.y, state.timestamp1, state.timestamp2,
                state.numReceivedPackets, state.timeOfSample
            });
        }

        outputJson["gw_data"]["states"] = states;
        outputJson["gw_data"]["actions"] = choiceArray;
        outputJson["gw_data"]["rewards"] = rewardArray;

        // Add transmission times to the JSON object
        outputJson["transmission_times"] = transmissionTimes;

        // Add stationary gateway reception times to the JSON object
        outputJson["stationary_gateway_reception_times"] = stationaryReceptionTimes;


        // Write the JSON object to the file
        outFile << outputJson.dump(4);  // Pretty print with 4-space indentation

        outFile.close();
    } else {
        EV << "Error opening file to write log data.\n";
    }
}


void StateLogger::finish() {
    writeToFile();
}


StateLogger::~StateLogger() {
    //autogenerated stub for destructor
}

} /* namespace inet */
